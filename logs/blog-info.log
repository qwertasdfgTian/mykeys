2020-08-11 00:01:44.926 INFO  [http-nio-8080-exec-3]com.lt.blog.aspect.RequestAspect.printRequestLog:109 -请求地址 : /comment/getByBlog
2020-08-11 00:01:44.926 INFO  [http-nio-8080-exec-8]com.lt.blog.aspect.RequestAspect.printRequestLog:109 -请求地址 : /blog/read/1290275213300314112
2020-08-11 00:01:44.992 INFO  [http-nio-8080-exec-3]com.lt.blog.aspect.RequestAspect.printRequestLog:110 -请求方式 : POST
2020-08-11 00:01:44.996 INFO  [http-nio-8080-exec-3]com.lt.blog.aspect.RequestAspect.printRequestLog:113 -IP : 127.0.0.1
2020-08-11 00:01:44.992 INFO  [http-nio-8080-exec-8]com.lt.blog.aspect.RequestAspect.printRequestLog:110 -请求方式 : GET
2020-08-11 00:01:44.998 INFO  [http-nio-8080-exec-3]com.lt.blog.aspect.RequestAspect.printRequestLog:115 -方法 : com.lt.blog.controller.CommentController.getByBlog
2020-08-11 00:01:45.000 INFO  [http-nio-8080-exec-3]com.lt.blog.aspect.RequestAspect.printRequestLog:117 -请求参数：[Page(blogId=1290275213300314112, currentPage=1, pageSize=20, totalPage=0, totalCount=0, list=null, params={}, sortColumn=null, sortMethod=asc)]
2020-08-11 00:01:44.999 INFO  [http-nio-8080-exec-8]com.lt.blog.aspect.RequestAspect.printRequestLog:113 -IP : 127.0.0.1
2020-08-11 00:01:45.006 INFO  [http-nio-8080-exec-8]com.lt.blog.aspect.RequestAspect.printRequestLog:115 -方法 : com.lt.blog.controller.BlogController.read
2020-08-11 00:01:45.006 INFO  [http-nio-8080-exec-8]com.lt.blog.aspect.RequestAspect.printRequestLog:117 -请求参数：[1290275213300314112]
2020-08-11 00:01:45.263 INFO  [http-nio-8080-exec-3]com.lt.blog.aspect.RequestAspect.doAround:64 -耗时 : 338
2020-08-11 00:01:45.268 INFO  [http-nio-8080-exec-3]com.lt.blog.aspect.RequestAspect.doAfterReturning:78 -返回值：{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blog":{"blogCollection":0,"blogComment":7,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":124,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":144},"commentBlog":"1290275213300314112","commentContent":"我是管理员","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:57:04","id":"1292852475845459968","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}},{"blog":{"blogCollection":0,"blogComment":6,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":120,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":139},"commentBlog":"1290275213300314112","commentContent":"我在北京等你","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:48:44","id":"1292850376575336448","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}},{"blog":{"blogCollection":0,"blogComment":5,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":120,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":138},"commentBlog":"1290275213300314112","commentContent":"啦啦啦啦","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:48:25","id":"1292850296464130048","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}},{"blog":{"blogCollection":0,"blogComment":4,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":120,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":137},"commentBlog":"1290275213300314112","commentContent":"我爱学java","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:48:12","id":"1292850241216757760","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}},{"blog":{"blogCollection":0,"blogComment":3,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":120,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":136},"commentBlog":"1290275213300314112","commentContent":"我是小乐","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:48:00","id":"1292850193015816192","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}}],"pageSize":5,"params":{},"sortMethod":"asc","totalCount":7,"totalPage":1},"msg":"操作成功！"}
2020-08-11 00:01:45.725 INFO  [http-nio-8080-exec-8]com.lt.blog.aspect.RequestAspect.doAround:64 -耗时 : 799
2020-08-11 00:01:45.726 INFO  [http-nio-8080-exec-8]com.lt.blog.aspect.RequestAspect.doAfterReturning:78 -返回值：{"code":20000,"data":{"blogCollection":0,"blogComment":7,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":125,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","createdTime":"2020-08-03 21:15:57","typeName":"Java"},"msg":"操作成功！"}
2020-08-11 00:01:55.213 INFO  [http-nio-8080-exec-10]com.lt.blog.aspect.RequestAspect.printRequestLog:109 -请求地址 : /comment/getByBlog
2020-08-11 00:01:55.214 INFO  [http-nio-8080-exec-10]com.lt.blog.aspect.RequestAspect.printRequestLog:110 -请求方式 : POST
2020-08-11 00:01:55.215 INFO  [http-nio-8080-exec-10]com.lt.blog.aspect.RequestAspect.printRequestLog:113 -IP : 127.0.0.1
2020-08-11 00:01:55.218 INFO  [http-nio-8080-exec-10]com.lt.blog.aspect.RequestAspect.printRequestLog:115 -方法 : com.lt.blog.controller.CommentController.getByBlog
2020-08-11 00:01:55.219 INFO  [http-nio-8080-exec-10]com.lt.blog.aspect.RequestAspect.printRequestLog:117 -请求参数：[Page(blogId=1290275213300314112, currentPage=2, pageSize=20, totalPage=1, totalCount=7, list=null, params={}, sortColumn=null, sortMethod=asc)]
2020-08-11 00:01:55.434 INFO  [http-nio-8080-exec-10]com.lt.blog.aspect.RequestAspect.doAround:64 -耗时 : 221
2020-08-11 00:01:55.435 INFO  [http-nio-8080-exec-10]com.lt.blog.aspect.RequestAspect.doAfterReturning:78 -返回值：{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blog":{"blogCollection":0,"blogComment":2,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":120,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":135},"commentBlog":"1290275213300314112","commentContent":"你好","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:47:53","id":"1292850161298489344","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}},{"blog":{"blogCollection":0,"blogComment":1,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":0,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":78,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":92},"commentBlog":"1290275213300314112","commentContent":"我是来刷评论的小乐","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-09 16:07:17","id":"1292371861614669824","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}}],"pageSize":5,"params":{},"sortMethod":"asc","totalCount":7,"totalPage":1},"msg":"操作成功！"}
2020-08-11 00:01:58.028 INFO  [http-nio-8080-exec-5]com.lt.blog.aspect.RequestAspect.printRequestLog:109 -请求地址 : /comment/getByBlog
2020-08-11 00:01:58.028 INFO  [http-nio-8080-exec-5]com.lt.blog.aspect.RequestAspect.printRequestLog:110 -请求方式 : POST
2020-08-11 00:01:58.029 INFO  [http-nio-8080-exec-5]com.lt.blog.aspect.RequestAspect.printRequestLog:113 -IP : 127.0.0.1
2020-08-11 00:01:58.029 INFO  [http-nio-8080-exec-5]com.lt.blog.aspect.RequestAspect.printRequestLog:115 -方法 : com.lt.blog.controller.CommentController.getByBlog
2020-08-11 00:01:58.030 INFO  [http-nio-8080-exec-5]com.lt.blog.aspect.RequestAspect.printRequestLog:117 -请求参数：[Page(blogId=1290275213300314112, currentPage=1, pageSize=20, totalPage=1, totalCount=7, list=null, params={}, sortColumn=null, sortMethod=asc)]
2020-08-11 00:01:58.229 INFO  [http-nio-8080-exec-5]com.lt.blog.aspect.RequestAspect.doAround:64 -耗时 : 201
2020-08-11 00:01:58.235 INFO  [http-nio-8080-exec-5]com.lt.blog.aspect.RequestAspect.doAfterReturning:78 -返回值：{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blog":{"blogCollection":0,"blogComment":7,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":124,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":144},"commentBlog":"1290275213300314112","commentContent":"我是管理员","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:57:04","id":"1292852475845459968","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}},{"blog":{"blogCollection":0,"blogComment":6,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":120,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":139},"commentBlog":"1290275213300314112","commentContent":"我在北京等你","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:48:44","id":"1292850376575336448","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}},{"blog":{"blogCollection":0,"blogComment":5,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":120,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":138},"commentBlog":"1290275213300314112","commentContent":"啦啦啦啦","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:48:25","id":"1292850296464130048","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}},{"blog":{"blogCollection":0,"blogComment":4,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":120,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":137},"commentBlog":"1290275213300314112","commentContent":"我爱学java","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:48:12","id":"1292850241216757760","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}},{"blog":{"blogCollection":0,"blogComment":3,"blogContent":"<h2>Java线程的等待与唤醒</h2>\n<p>生产者和消费者必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行，同步使用的锁对象必须保证唯一。</p>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"Thread_2\"></a>Thread中重要方法</h3>\n<p>void wait() 在其他线程调用此对象的notify（）方法或notifyall（）方法前，导致当前线程等待。</p>\n<p>void notify() 唤醒在此对象监视器上等待的单个线程后，会继续执行wait方法之后的代码。</p>\n<p>void notifyAll() 唤醒所有等待线程</p>\n<p>void wait（long m）在毫秒结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/blocke状态。</p>\n<p>void sleep（long m）在毫秒结束之后，线程睡醒进入到Runnable/blocke状态</p>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"_12\"></a>使用</h3>\n<p>我们自己创建线程类的子类时，不要忘了写上继承extend。再run（）方法中写入线程同步的代码，在客户端调用时，直接调用start方法，默认自动调用run方法的代码。</p>\n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"_14\"></a>案例</h3>\n<p>先写一个产品类。</p>\n<pre class=\"language-javascript\"><code>//产品类\npublic class Product {\n    //属性代表产品是否还有\n    boolean flag=false;\n}</code></pre>\n<p>生产者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//生产者类\npublic class Producer extends Thread {\n    private Product pr;\n\n    //构适有参构适函教，让产品类实例的对象作为的对象\n    public Producer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        //一直生产该商品\n        while (true) {\n            //使用锁对象\n            synchronized (pr) {\n                //如果该产品还存在，\n                if (pr.flag == true) {\n                    try {\n                        //生产者停止生产\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //否则生产者开始生产\n                System.out.println(\"生产者正在生产\");\n                try {\n                    //生产时间为5 秒\n                    Thread.sleep(5000);\n                    System.out.println(\"请等待5秒\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //生产完成\n                pr.flag = true;\n                //唤醒消费者\n                pr.notify();\n                System.out.println(\"生产者生产完了，消费者开始使用\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>消费者类：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>//消费者类\npublic class Consumer extends Thread {\n    private Product pr;\n\n    public Consumer(Product pr) {\n        this.pr = pr;\n    }\n    public void run(){\n        while (true) {\n            //锁对象\n            synchronized (pr) {\n                // 如果产品没有\n                if (pr.flag == false) {\n                    try {\n                        //则消费者进行等待\n                        pr.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果产品还有，消费者使用产品\n                System.out.println(\"消费者正在使用\");\n                //消耗完产品，改变产品属性\n                pr.flag = false;\n                //唤醒生产者，等待再次生产产品\n                pr.notify();\n                System.out.println(\"产品已经使用完了，生产者开始生产\");\n                System.out.println(\"=============================\");\n            }\n        }\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>主函数：</p>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<pre class=\"language-javascript\"><code>public class test {\n    public static void main(String[] args) {\n        //实的化产品\n        Product pr=new Product();\n        // 实例化 生产者，并运行run 方法\n        new Producer(pr).start();\n        //实例化消费者，并运行run 方法\n        new Consumer(pr).start();\n    }\n}</code></pre>\n<pre class=\"prettyprint\"><code class=\"prism language-javascript has-numbering\"></code></pre>\n<p>因为生产者和消费者都是用的一个锁对象，而锁在同一个线程类中会同行第一个进去该锁的线程，等该进程执行完后会将锁对象归还，下一个进程接着执行，在不同线程类同一个锁对象被设置等待了，由于是一个锁对象，另一个线程类的进程会等待，从而做到了线程类之间的交流。</p>\n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"_120\"></a>运行结果</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200624191546978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NUUkxLSw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_122\"></a>总结</h2>\n<p>以上就是Java线程的等待与唤醒介绍和练习。。</p>","blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":120,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","blogType":1,"createdTime":"2020-08-03 21:15:57","version":136},"commentBlog":"1290275213300314112","commentContent":"我是小乐","commentFlag":false,"commentGood":0,"commentUser":1,"createdTime":"2020-08-10 23:48:00","id":"1292850193015816192","user":{"header":"http://39.101.131.194/group1/M00/00/00/rBcgvV8vrG6Aent4AAAoIqhdV8g053.jpg","name":"小乐","nickname":"乐乐","sex":1,"userEmail":"1934381181@qq.com","userId":1,"username":"xiaole","version":2}}],"pageSize":5,"params":{},"sortMethod":"asc","totalCount":7,"totalPage":1},"msg":"操作成功！"}
2020-08-11 00:02:19.034 INFO  [http-nio-8080-exec-9]com.lt.blog.aspect.RequestAspect.printRequestLog:109 -请求地址 : /blog/getByPage
2020-08-11 00:02:19.045 INFO  [http-nio-8080-exec-2]com.lt.blog.aspect.RequestAspect.printRequestLog:109 -请求地址 : /carousel/findAll
2020-08-11 00:02:19.045 INFO  [http-nio-8080-exec-2]com.lt.blog.aspect.RequestAspect.printRequestLog:110 -请求方式 : GET
2020-08-11 00:02:19.045 INFO  [http-nio-8080-exec-9]com.lt.blog.aspect.RequestAspect.printRequestLog:110 -请求方式 : POST
2020-08-11 00:02:19.048 INFO  [http-nio-8080-exec-2]com.lt.blog.aspect.RequestAspect.printRequestLog:113 -IP : 127.0.0.1
2020-08-11 00:02:19.050 INFO  [http-nio-8080-exec-9]com.lt.blog.aspect.RequestAspect.printRequestLog:113 -IP : 127.0.0.1
2020-08-11 00:02:19.050 INFO  [http-nio-8080-exec-2]com.lt.blog.aspect.RequestAspect.printRequestLog:115 -方法 : com.lt.blog.controller.CarouselController.findAll
2020-08-11 00:02:19.050 INFO  [http-nio-8080-exec-9]com.lt.blog.aspect.RequestAspect.printRequestLog:115 -方法 : com.lt.blog.controller.BlogController.getByPage
2020-08-11 00:02:19.050 INFO  [http-nio-8080-exec-2]com.lt.blog.aspect.RequestAspect.printRequestLog:117 -请求参数：[]
2020-08-11 00:02:19.050 INFO  [http-nio-8080-exec-9]com.lt.blog.aspect.RequestAspect.printRequestLog:117 -请求参数：[Page(blogId=null, currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=desc)]
2020-08-11 00:02:19.144 INFO  [http-nio-8080-exec-2]com.lt.blog.aspect.RequestAspect.doAround:64 -耗时 : 99
2020-08-11 00:02:19.146 INFO  [http-nio-8080-exec-2]com.lt.blog.aspect.RequestAspect.doAfterReturning:78 -返回值：{"code":20000,"data":[{"href":"https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/107902863","id":1,"src":"https://csdnimg.cn/feed/20200810/4f0038048490bd4dd4fa1571a7c426f2.jpg","text":"Python再夺冠，上古语言COBOL大流行"},{"href":"https://blog.csdn.net/csdnnews/article/details/107903205","id":3,"src":"http://39.101.131.194/group1/M00/00/00/rBcgvV8xKXKAeuOOAAI3RYym_dM295.jpg","text":"统计 GitHub 评分、收录有意思的 README，GitHub 热点速览"}],"msg":"操作成功！"}
2020-08-11 00:02:19.247 INFO  [http-nio-8080-exec-9]com.lt.blog.aspect.RequestAspect.doAround:64 -耗时 : 213
2020-08-11 00:02:19.248 INFO  [http-nio-8080-exec-9]com.lt.blog.aspect.RequestAspect.doAfterReturning:78 -返回值：{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1290277842621411328","blogRead":21,"blogTitle":"Mybatis组成部分","createdTime":"2020-08-03 21:26:24","typeName":"Java","updateTime":"2020-08-10 21:08:23"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1290276403400519680","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8pVAKAPD1jAAA-72VPJ-A472.gif","blogRead":21,"blogTitle":"varchar字段长度最好是2的n次方-1","createdTime":"2020-08-03 21:20:41","typeName":"Mysql","updateTime":"2020-08-10 21:22:23"},{"blogCollection":0,"blogComment":7,"blogGoods":1,"blogId":"1290275213300314112","blogImage":"http://39.101.131.194/group1/M00/00/00/rBcgvV8o0WyADLfQAABLhgCnExs455.jpg","blogRead":125,"blogRemark":"Java线程","blogTitle":"Java线程的等待与唤醒实例","createdTime":"2020-08-03 21:15:57","typeName":"Java","updateTime":"2020-08-11 00:01:45"}],"pageSize":10,"params":{},"sortColumn":"created_time","sortMethod":"desc","totalCount":3,"totalPage":1},"msg":"操作成功！"}
